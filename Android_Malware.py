# Importing the dependencies
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import accuracy_score

# Importing different models
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import MultinomialNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier

BINARY_VALUE_FOR_MALWARE = 1
BINARY_VALUE_FOR_BENIGN = 0

PATH_TO_CSV_FILES = ['resources/Permissions_and_receiver.csv','resources/Permissions_only.csv']


def get_prediction_for_input_after_training(path_to_csv_file, permissions_used):
    # Data collection and preprocessing
    # Loading data from CSV to Pandas DataFrame
    raw_permission_data = pd.read_csv(path_to_csv_file)

    # Replace null values with null string
    permission_data = raw_permission_data.where(pd.notnull(raw_permission_data), '')

    # Labelling inputs [1 = malware, 0 = benign]
    permission_data.loc[permission_data['App_types'] == 'malware', 'App_types'] = BINARY_VALUE_FOR_MALWARE
    permission_data.loc[permission_data['App_types'] == 'benign', 'App_types'] = BINARY_VALUE_FOR_BENIGN

    # Splitting data into text and labels
    X = permission_data['Permission_Combined']
    Y = permission_data['App_types']

    # Split data into training and test data sets
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=2)

    # Feature extraction

    # Converting text to numericals/feature vectors
    feature_extraction = TfidfVectorizer(min_df=1, lowercase='True')

    # Extracting feature from data
    X_train_features = feature_extraction.fit_transform(X_train)
    X_test_features = feature_extraction.transform(X_test)

    # Converting O/P labels to integers (from objects)
    Y_train = Y_train.astype('int')
    Y_test = Y_test.astype('int')

    # Training the ML model - LogisticRegression
    models = []
    models.append(LogisticRegression())
    models.append(MultinomialNB())
    models.append(KNeighborsClassifier(n_neighbors=3))
    models.append(RandomForestClassifier())

    predictions_on_data_training = []
    predictions_on_data_test = []
    accuracy_on_data_training = []
    accuracy_on_data_test = []

    # Headers for Accuracy Table
    accuracy_data_table = [["Model", "Training Data", "Test Data", "Training-Test"]]

    predictions_on_input = []

    # Training the LogisticRegression model with training data
    for i in range(0, len(models)):
        models[i].fit(X_train_features, Y_train)

        predictions_on_data_training.append(models[i].predict(X_train_features))
        predictions_on_data_test.append(models[i].predict(X_test_features))

        accuracy_on_data_training = accuracy_score(Y_train, predictions_on_data_training[i])
        accuracy_on_data_test = accuracy_score(Y_test, predictions_on_data_test[i])

        accuracy_data_table.append([models[i], accuracy_on_data_training, accuracy_on_data_test,
                                    (accuracy_on_data_training - accuracy_on_data_test)])

        if permissions_used is not None:

            permissions_used_features = feature_extraction.transform(permissions_used)

            if models[i].predict(permissions_used_features) == BINARY_VALUE_FOR_MALWARE:
                predictions_on_input.append([str(type(models[i])), BINARY_VALUE_FOR_MALWARE])
            else:
                predictions_on_input.append([str(type(models[i])), BINARY_VALUE_FOR_BENIGN])

    return (predictions_on_input)


def get_prediction_for_training_data_after_training(path_to_csv_file):
    # Data collection and preprocessing
    # Loading data from CSV to Pandas DataFrame
    raw_permission_data = pd.read_csv(path_to_csv_file)

    # Replace null values with null string
    permission_data = raw_permission_data.where(pd.notnull(raw_permission_data), '')

    # Labelling inputs [1 = malware, 0 = benign]
    permission_data.loc[permission_data['App_types'] == 'malware', 'App_types'] = BINARY_VALUE_FOR_MALWARE
    permission_data.loc[permission_data['App_types'] == 'benign', 'App_types'] = BINARY_VALUE_FOR_BENIGN

    # Splitting data into text and labels
    X = permission_data['Permission_Combined']
    Y = permission_data['App_types']

    # Split data into training and test data sets
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=2)

    # Feature extraction

    # Converting text to numericals/feature vectors
    feature_extraction = TfidfVectorizer(min_df=1, lowercase='True')

    # Extracting feature from data
    X_train_features = feature_extraction.fit_transform(X_train)
    X_test_features = feature_extraction.transform(X_test)

    # Converting O/P labels to integers (from objects)
    Y_train = Y_train.astype('int')
    Y_test = Y_test.astype('int')

    # Training the ML model - LogisticRegression
    models = []
    models.append(LogisticRegression())
    models.append(MultinomialNB())
    models.append(KNeighborsClassifier(n_neighbors=3))
    models.append(RandomForestClassifier())

    predictions_on_data_training = []
    predictions_on_data_test = []
    accuracy_on_data_training = []
    accuracy_on_data_test = []

    # Headers for Accuracy Table
    accuracy_data_table = [["Model", "Training Data", "Test Data", "Training-Test"]]

    # Training the LogisticRegression model with training data
    for i in range(0, len(models)):
        models[i].fit(X_train_features, Y_train)

        predictions_on_data_training.append(models[i].predict(X_train_features))
        predictions_on_data_test.append(models[i].predict(X_test_features))

        accuracy_on_data_training = accuracy_score(Y_train, predictions_on_data_training[i])
        accuracy_on_data_test = accuracy_score(Y_test, predictions_on_data_test[i])

        accuracy_data_table.append([models[i], accuracy_on_data_training, accuracy_on_data_test,
                                    (accuracy_on_data_training - accuracy_on_data_test)])

    return (accuracy_data_table)

def get_prediction_after_training_with_default_files():
    permissions_used = ["android.permission.ACCESS_NETWORK_STATE android.permission.GET_TASKS android.permission.INTERNET"]
    for path in PATH_TO_CSV_FILES:
        prediction_for_input = get_prediction_for_input_after_training(path, permissions_used)
        print(permissions_used[0], " is \n", prediction_for_input)

    permissions_used = ["android.permission.ACCESS_NETWORK_STATE      android.permission.ACCESS_WIFI_STATE                                                                             android.permission.CHANGE_NETWORK_STATE android.permission.CHANGE_WIFI_STATE                                                          android.permission.INTERNET                                android.permission.MODIFY_PHONE_STATE android.permission.MOUNT_UNMOUNT_FILESYSTEMS                         android.permission.READ_LOGS              android.permission.RECEIVE_BOOT_COMPLETED                  android.permission.RESTART_PACKAGES                                                      android.permission.WRITE_APN_SETTINGS      android.permission.WRITE_SETTINGSandroid.permission.WRITE_SMS   "]
    for path in PATH_TO_CSV_FILES:
        prediction_for_input = get_prediction_for_input_after_training(path, permissions_used)
        print(permissions_used[0], " is \n", prediction_for_input)


def main():
    get_prediction_after_training_with_default_files()


if __name__ == "__main__":
    main()

