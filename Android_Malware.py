# Importing the dependencies
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import accuracy_score

# Importing different models
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import MultinomialNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier

path_to_csv_files = ['resources/Permissions_and_receiver.csv','resources/Permissions_only.csv']


def get_accuracy_after_training_with_file(path_to_csv_file):
    # Data collection and preprocessing
    # Loading data from CSV to Pandas DataFrame
    raw_permission_data = pd.read_csv(path_to_csv_file)
    # print("raw_permission_data \n:", raw_permission_data)

    # Replace null values with null string
    permission_data = raw_permission_data.where(pd.notnull(raw_permission_data), '')
    # print("premission_data \n:", permission_data)

    # Printing first 5 rows of the data frame
    # print("First 5 rows \n:", permission_data.head())

    # Checking number of rows and columns
    # print("Size of rows and columns \n:", permission_data.shape)

    # Labelling inputs [1 = ham, 0 = spam]
    permission_data.loc[permission_data['App_types'] == 'malware', 'App_types'] = 1
    permission_data.loc[permission_data['App_types'] == 'benign', 'App_types'] = 0
    # print("After Labelling, permission_data \n:", permission_data)

    # Split data into text and labels
    X = permission_data['Permission_Combined']
    Y = permission_data['App_types']
    # print('X: \n', X)
    # print('Y: \n', Y)

    # Split data into training and test data sets
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=2)
    # print('X_train: \n', X_train)
    # print('X_test: \n', X_test)
    # print('Ytrain: \n', Y_train)
    # print('Y_test: \n', Y_test)

    # Feature extraction

    # Converting text to numericals/feature vectors
    feature_extraction = TfidfVectorizer(min_df=1, lowercase='True')
    print('feature_extraction: \n', feature_extraction)

    # training the model
    X_train_features = feature_extraction.fit_transform(X_train)
    X_test_features = feature_extraction.transform(X_test)

    # Converting O/P labels to integers (from objects)
    Y_train = Y_train.astype('int')
    Y_test = Y_test.astype('int')

    # Training the ML model - LogisticRegression

    models = []
    models.append(LogisticRegression())
    models.append(MultinomialNB())
    models.append(KNeighborsClassifier(n_neighbors=3))
    models.append(RandomForestClassifier())

    predictions_on_data_training = []
    predictions_on_data_test = []
    accuracy_on_data_training = []
    accuracy_on_data_test = []

    # output_data_table_headers = ["Index", "Training Data", "Test Data", "Training-Test"]
    output_data = [["Model", "Training Data", "Test Data", "Training-Test"]]

    # Training the LogisticRegression model with training data
    for i in range(0, len(models)):
        models[i].fit(X_train_features, Y_train)

        predictions_on_data_training.append(models[i].predict(X_train_features))
        predictions_on_data_test.append(models[i].predict(X_test_features))

        accuracy_on_data_training = accuracy_score(Y_train, predictions_on_data_training[i])
        accuracy_on_data_test = accuracy_score(Y_test, predictions_on_data_test[i])

        output_data.append([models[i], accuracy_on_data_training, accuracy_on_data_test,
                            (accuracy_on_data_training - accuracy_on_data_test)])

    #     print(i+1,
    #       accuracy_on_data_training,
    #       accuracy_on_data_test,
    #       (accuracy_on_data_training - accuracy_on_data_test), sep="\t")

    print("Accuracy Score with Training Data")
    print(pd.DataFrame(output_data))


def get_prediction_after_training_with_default_files():
    for path in path_to_csv_files:
        print("File is: ", path)
        get_accuracy_after_training_with_file(path)


def main():
    get_prediction_after_training_with_default_files()


if __name__ == "__main__":
    main()

