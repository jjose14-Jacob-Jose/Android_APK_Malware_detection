# Importing the dependencies
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import accuracy_score

# Importing different models
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import MultinomialNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier

BINARY_VALUE_FOR_MALWARE = 1
BINARY_VALUE_FOR_BENIGN = 0
TEXT_FOR_MALWARE = "Malware"
TEXT_FOR_BENIGN = "Benign"
TEXT_FOR_TABLE_SEPARATOR = " | "

MODELS_USED = []

PATH_TO_CSV_FILES = ['resources/Permissions_and_receiver.csv', 'resources/Permissions_only.csv', 'resources/receiver_only-CSV.csv']

def training_models_initialize():
    # Training the ML model - LogisticRegression
    MODELS_USED.append(LogisticRegression())
    MODELS_USED.append(MultinomialNB())
    MODELS_USED.append(KNeighborsClassifier(n_neighbors=3))
    MODELS_USED.append(RandomForestClassifier())



def get_prediction_for_input_after_training(path_to_csv_file, permissions_used):
    # Data collection and preprocessing
    # Loading data from CSV to Pandas DataFrame
    raw_permission_data = pd.read_csv(path_to_csv_file)

    # Replace null values with null string
    permission_data = raw_permission_data.where(pd.notnull(raw_permission_data), '')

    # Labelling inputs [1 = malware, 0 = benign]
    permission_data.loc[permission_data['App_types'] == 'malware', 'App_types'] = BINARY_VALUE_FOR_MALWARE
    permission_data.loc[permission_data['App_types'] == 'benign', 'App_types'] = BINARY_VALUE_FOR_BENIGN

    # Splitting data into text and labels
    X = permission_data['Permission_Combined']
    Y = permission_data['App_types']

    # Split data into training and test data sets
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=2)

    # Feature extraction

    # Converting text to numericals/feature vectors
    feature_extraction = TfidfVectorizer(min_df=1, lowercase='True')

    # Extracting feature from data
    X_train_features = feature_extraction.fit_transform(X_train)
    X_test_features = feature_extraction.transform(X_test)

    # Converting O/P labels to integers (from objects)
    Y_train = Y_train.astype('int')
    Y_test = Y_test.astype('int')

    if len(MODELS_USED) == 0:
        training_models_initialize()

    predictions_on_data_training = []
    predictions_on_data_test = []
    accuracy_on_data_training = []
    accuracy_on_data_test = []

    # Headers for Accuracy Table
    accuracy_data_table = [["Model", "Training Data", "Test Data", "Training-Test"]]

    predictions_on_input = []

    # Training the LogisticRegression model with training data
    for i in range(0, len(MODELS_USED)):
        MODELS_USED[i].fit(X_train_features, Y_train)

        predictions_on_data_training.append(MODELS_USED[i].predict(X_train_features))
        predictions_on_data_test.append(MODELS_USED[i].predict(X_test_features))

        accuracy_on_data_training = accuracy_score(Y_train, predictions_on_data_training[i])
        accuracy_on_data_test = accuracy_score(Y_test, predictions_on_data_test[i])

        accuracy_data_table.append([MODELS_USED[i], accuracy_on_data_training, accuracy_on_data_test,
                                    (accuracy_on_data_training - accuracy_on_data_test)])

        if permissions_used is not None:

            permissions_used_features = feature_extraction.transform(permissions_used)

            if MODELS_USED[i].predict(permissions_used_features) == BINARY_VALUE_FOR_MALWARE:
                predictions_on_input.append([str(type(MODELS_USED[i])), BINARY_VALUE_FOR_MALWARE])
            else:
                predictions_on_input.append([str(type(MODELS_USED[i])), BINARY_VALUE_FOR_BENIGN])

    return (predictions_on_input)


def get_prediction_for_training_data_after_training(path_to_csv_file):
    # Data collection and preprocessing
    # Loading data from CSV to Pandas DataFrame
    raw_permission_data = pd.read_csv(path_to_csv_file)

    # Replace null values with null string
    permission_data = raw_permission_data.where(pd.notnull(raw_permission_data), '')

    # Labelling inputs [1 = malware, 0 = benign]
    permission_data.loc[permission_data['App_types'] == 'malware', 'App_types'] = BINARY_VALUE_FOR_MALWARE
    permission_data.loc[permission_data['App_types'] == 'benign', 'App_types'] = BINARY_VALUE_FOR_BENIGN

    # Splitting data into text and labels
    X = permission_data['Permission_Combined']
    Y = permission_data['App_types']

    # Split data into training and test data sets
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=2)

    # Feature extraction

    # Converting text to numericals/feature vectors
    feature_extraction = TfidfVectorizer(min_df=1, lowercase='True')

    # Extracting feature from data
    X_train_features = feature_extraction.fit_transform(X_train)
    X_test_features = feature_extraction.transform(X_test)

    # Converting O/P labels to integers (from objects)
    # Y_train = pd.to_numeric(Y_train, errors="coerce")
    Y_train = Y_train.astype('int')
    Y_test = Y_test.astype('int')

    # Training the ML model - LogisticRegression
    models = []
    models.append(LogisticRegression())
    models.append(MultinomialNB())
    models.append(KNeighborsClassifier(n_neighbors=3))
    models.append(RandomForestClassifier())

    predictions_on_data_training = []
    predictions_on_data_test = []
    accuracy_on_data_training = []
    accuracy_on_data_test = []

    # Headers for Accuracy Table
    accuracy_data_table = [["Model", "Training Data", "Test Data", "Training-Test"]]

    # Training the LogisticRegression model with training data
    for i in range(0, len(models)):
        models[i].fit(X_train_features, Y_train)

        predictions_on_data_training.append(models[i].predict(X_train_features))
        predictions_on_data_test.append(models[i].predict(X_test_features))

        accuracy_on_data_training = accuracy_score(Y_train, predictions_on_data_training[i])
        accuracy_on_data_test = accuracy_score(Y_test, predictions_on_data_test[i])

        accuracy_data_table.append([models[i], accuracy_on_data_training, accuracy_on_data_test,
                                    (accuracy_on_data_training - accuracy_on_data_test)])

    return (accuracy_data_table)

def print_output_in_format(name_file_CSV, permissions_used, predicition_for_permissions_used):
    print("Based on learning from ", name_file_CSV," if the permissions are: \n", permissions_used)
    print("Prediction Model", TEXT_FOR_TABLE_SEPARATOR,  "App Type (", TEXT_FOR_BENIGN, "/", TEXT_FOR_MALWARE, ")")
    for i in range(len(MODELS_USED)):
        if predicition_for_permissions_used[i][1] == BINARY_VALUE_FOR_MALWARE:
            prediction_in_text = TEXT_FOR_MALWARE
        else:
            prediction_in_text = TEXT_FOR_BENIGN
        print(predicition_for_permissions_used[i][0], TEXT_FOR_TABLE_SEPARATOR, prediction_in_text)
    print("\n")

def print_accuracy_score_with_training_data():

    for path in PATH_TO_CSV_FILES:
        accuracy_table = get_prediction_for_training_data_after_training(path)
        print("*******************************", "Accuracy Score: ", path, " *******************************", "\n")
        for i in range(len(accuracy_table)):
            str_row = ""
            for j in range(len(accuracy_table[i])):
                str_row = str_row + str(accuracy_table[i][j]) + TEXT_FOR_TABLE_SEPARATOR
            print(str_row)
        print("\n")


def get_prediction_after_training_with_default_files():

    permissions_used = ["android.permission.ACCESS_NETWORK_STATE android.permission.GET_TASKS android.permission.INTERNET"]
    for path in PATH_TO_CSV_FILES:
        prediction_for_input = get_prediction_for_input_after_training(path, permissions_used)
        print_output_in_format(path, permissions_used[0], prediction_for_input)

    permissions_used = ["android.permission.ACCESS_NETWORK_STATE      android.permission.ACCESS_WIFI_STATE                                                                             android.permission.CHANGE_NETWORK_STATE android.permission.CHANGE_WIFI_STATE                                                          android.permission.INTERNET                                android.permission.MODIFY_PHONE_STATE android.permission.MOUNT_UNMOUNT_FILESYSTEMS                         android.permission.READ_LOGS              android.permission.RECEIVE_BOOT_COMPLETED                  android.permission.RESTART_PACKAGES                                                      android.permission.WRITE_APN_SETTINGS      android.permission.WRITE_SETTINGSandroid.permission.WRITE_SMS   "]
    for path in PATH_TO_CSV_FILES:
        prediction_for_input = get_prediction_for_input_after_training(path, permissions_used)
        print_output_in_format(path, permissions_used[0], prediction_for_input)


def main():
    print_accuracy_score_with_training_data()
    get_prediction_after_training_with_default_files()


if __name__ == "__main__":
    main()

