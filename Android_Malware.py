# Importing the dependencies
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import accuracy_score

# Importing different models
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import MultinomialNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier

BINARY_VALUE_FOR_MALWARE = 1
BINARY_VALUE_FOR_BENIGN = 0

PATH_TO_CSV_FILES = ['resources/Permissions_and_receiver.csv','resources/Permissions_only.csv']

def get_prediction_after_training_input(path_to_csv_file, permissions_used):
    # Data collection and preprocessing
    # Loading data from CSV to Pandas DataFrame
    raw_permission_data = pd.read_csv(path_to_csv_file)
    # print("raw_permission_data \n:", raw_permission_data)

    # Replace null values with null string
    permission_data = raw_permission_data.where(pd.notnull(raw_permission_data), '')
    # print("premission_data \n:", permission_data)

    # Printing first 5 rows of the data frame
    # print("First 5 rows \n:", permission_data.head())

    # Checking number of rows and columns
    # print("Size of rows and columns \n:", permission_data.shape)

    # Labelling inputs [1 = ham, 0 = spam]
    permission_data.loc[permission_data['App_types'] == 'malware', 'App_types'] = BINARY_VALUE_FOR_MALWARE
    permission_data.loc[permission_data['App_types'] == 'benign', 'App_types'] = BINARY_VALUE_FOR_BENIGN
    # print("After Labelling, permission_data \n:", permission_data)

    # Split data into text and labels
    X = permission_data['Permission_Combined']
    Y = permission_data['App_types']
    # print('X: \n', X)
    # print('Y: \n', Y)

    # Split data into training and test data sets
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=2)
    # print('X_train: \n', X_train)
    # print('X_test: \n', X_test)
    # print('Ytrain: \n', Y_train)
    # print('Y_test: \n', Y_test)

    # Feature extraction

    # Converting text to numericals/feature vectors
    feature_extraction = TfidfVectorizer(min_df=1, lowercase='True')
    #     print('feature_extraction: \n', feature_extraction)

    # training the model
    X_train_features = feature_extraction.fit_transform(X_train)
    X_test_features = feature_extraction.transform(X_test)

    # Converting O/P labels to integers (from objects)
    Y_train = Y_train.astype('int')
    Y_test = Y_test.astype('int')

    # Training the ML model - LogisticRegression

    models = []
    models.append(LogisticRegression())
    models.append(MultinomialNB())
    models.append(KNeighborsClassifier(n_neighbors=3))
    models.append(RandomForestClassifier())

    predictions_on_data_training = []
    predictions_on_data_test = []
    accuracy_on_data_training = []
    accuracy_on_data_test = []

    # output_data_table_headers = ["Index", "Training Data", "Test Data", "Training-Test"]
    output_data = [["Model", "Training Data", "Test Data", "Training-Test"]]

    predictions_on_input = []

    # Training the LogisticRegression model with training data
    for i in range(0, len(models)):
        models[i].fit(X_train_features, Y_train)

        predictions_on_data_training.append(models[i].predict(X_train_features))
        predictions_on_data_test.append(models[i].predict(X_test_features))

        accuracy_on_data_training = accuracy_score(Y_train, predictions_on_data_training[i])
        accuracy_on_data_test = accuracy_score(Y_test, predictions_on_data_test[i])

        output_data.append([models[i], accuracy_on_data_training, accuracy_on_data_test,
                            (accuracy_on_data_training - accuracy_on_data_test)])

        #         print(permissions_used)
        #         print(feature_extraction.transform(permissions_used))

        if permissions_used is not None:

            permissions_used_features = feature_extraction.transform(permissions_used)
            print("Output: ", models[i].predict(permissions_used_features))

            if models[i].predict(permissions_used_features) == BINARY_VALUE_FOR_MALWARE:
                predictions_on_input.append([models[i], BINARY_VALUE_FOR_MALWARE])
            else:
                predictions_on_input.append([models[i], BINARY_VALUE_FOR_BENIGN])
    return (predictions_on_input)

    #     print(i+1,
    #       accuracy_on_data_training,
    #       accuracy_on_data_test,
    #       (accuracy_on_data_training - accuracy_on_data_test), sep="\t")


    #     print("Accuracy Table")
    #     print(pd.DataFrame(output_data))


def get_prediction_after_training_with_default_files():
    permissions_used = [
        "android.permission.ACCESS_NETWORK_STATE android.permission.GET_TASKS android.permission.INTERNET"]
    for path in PATH_TO_CSV_FILES:
        print("Path is: ", path)
        ouput = get_prediction_after_training_input(path, permissions_used)
        print(ouput)


    permissions_used = [
        "android.permission.ACCESS_NETWORK_STATE      android.permission.ACCESS_WIFI_STATE                                                                             android.permission.CHANGE_NETWORK_STATE android.permission.CHANGE_WIFI_STATE                                                          android.permission.INTERNET                                android.permission.MODIFY_PHONE_STATE android.permission.MOUNT_UNMOUNT_FILESYSTEMS                         android.permission.READ_LOGS              android.permission.RECEIVE_BOOT_COMPLETED                  android.permission.RESTART_PACKAGES                                                      android.permission.WRITE_APN_SETTINGS      android.permission.WRITE_SETTINGSandroid.permission.WRITE_SMS   "]

    for path in PATH_TO_CSV_FILES:
        print("Path is: ", path)
        ouput = get_prediction_after_training_input(path, permissions_used)

def main():
    get_prediction_after_training_with_default_files()


if __name__ == "__main__":
    main()

